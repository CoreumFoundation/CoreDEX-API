// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: domain/update/update.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Network, networkFromJSON, networkToJSON } from "../metadata/metadata";

export const protobufPackage = "update";

export enum Action {
  SUBSCRIBE = 0,
  UNSUBSCRIBE = 1,
  CLOSE = 2,
  RESPONSE = 3,
  UNRECOGNIZED = -1,
}

export function actionFromJSON(object: any): Action {
  switch (object) {
    case 0:
    case "SUBSCRIBE":
      return Action.SUBSCRIBE;
    case 1:
    case "UNSUBSCRIBE":
      return Action.UNSUBSCRIBE;
    case 2:
    case "CLOSE":
      return Action.CLOSE;
    case 3:
    case "RESPONSE":
      return Action.RESPONSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Action.UNRECOGNIZED;
  }
}

export function actionToJSON(object: Action): string {
  switch (object) {
    case Action.SUBSCRIBE:
      return "SUBSCRIBE";
    case Action.UNSUBSCRIBE:
      return "UNSUBSCRIBE";
    case Action.CLOSE:
      return "CLOSE";
    case Action.RESPONSE:
      return "RESPONSE";
    case Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Method {
  METHOD_DO_NOT_USE = 0,
  /** TRADES_FOR_SYMBOL - ID: {denom1}_{denom2} */
  TRADES_FOR_SYMBOL = 1,
  /** TRADES_FOR_ACCOUNT - ID: {account} */
  TRADES_FOR_ACCOUNT = 2,
  /** TRADES_FOR_ACCOUNT_AND_SYMBOL - ID: {account}_{denom1}_{denom2} */
  TRADES_FOR_ACCOUNT_AND_SYMBOL = 3,
  /** OHLC - ID: {denom1}_{denom2}_{interval} */
  OHLC = 4,
  /** TICKER - ID: {denom1}_{denom2} */
  TICKER = 5,
  /** ORDERBOOK - ID: {denom1}_{denom2} */
  ORDERBOOK = 6,
  /** ORDERBOOK_FOR_SYMBOL_AND_ACCOUNT - ID: {account}_{denom1}_{denom2} */
  ORDERBOOK_FOR_SYMBOL_AND_ACCOUNT = 7,
  /** WALLET - ID: {account} */
  WALLET = 8,
  UNRECOGNIZED = -1,
}

export function methodFromJSON(object: any): Method {
  switch (object) {
    case 0:
    case "METHOD_DO_NOT_USE":
      return Method.METHOD_DO_NOT_USE;
    case 1:
    case "TRADES_FOR_SYMBOL":
      return Method.TRADES_FOR_SYMBOL;
    case 2:
    case "TRADES_FOR_ACCOUNT":
      return Method.TRADES_FOR_ACCOUNT;
    case 3:
    case "TRADES_FOR_ACCOUNT_AND_SYMBOL":
      return Method.TRADES_FOR_ACCOUNT_AND_SYMBOL;
    case 4:
    case "OHLC":
      return Method.OHLC;
    case 5:
    case "TICKER":
      return Method.TICKER;
    case 6:
    case "ORDERBOOK":
      return Method.ORDERBOOK;
    case 7:
    case "ORDERBOOK_FOR_SYMBOL_AND_ACCOUNT":
      return Method.ORDERBOOK_FOR_SYMBOL_AND_ACCOUNT;
    case 8:
    case "WALLET":
      return Method.WALLET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Method.UNRECOGNIZED;
  }
}

export function methodToJSON(object: Method): string {
  switch (object) {
    case Method.METHOD_DO_NOT_USE:
      return "METHOD_DO_NOT_USE";
    case Method.TRADES_FOR_SYMBOL:
      return "TRADES_FOR_SYMBOL";
    case Method.TRADES_FOR_ACCOUNT:
      return "TRADES_FOR_ACCOUNT";
    case Method.TRADES_FOR_ACCOUNT_AND_SYMBOL:
      return "TRADES_FOR_ACCOUNT_AND_SYMBOL";
    case Method.OHLC:
      return "OHLC";
    case Method.TICKER:
      return "TICKER";
    case Method.ORDERBOOK:
      return "ORDERBOOK";
    case Method.ORDERBOOK_FOR_SYMBOL_AND_ACCOUNT:
      return "ORDERBOOK_FOR_SYMBOL_AND_ACCOUNT";
    case Method.WALLET:
      return "WALLET";
    case Method.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Subscribe {
  Action: Action;
  Subscription: Subscription | undefined;
}

export interface Subscription {
  Method: Method;
  ID: string;
  Network: Network;
  Content: string;
}

function createBaseSubscribe(): Subscribe {
  return { Action: 0, Subscription: undefined };
}

export const Subscribe = {
  encode(message: Subscribe, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Action !== 0) {
      writer.uint32(8).int32(message.Action);
    }
    if (message.Subscription !== undefined) {
      Subscription.encode(message.Subscription, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Subscribe {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.Action = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Subscription = Subscription.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subscribe {
    return {
      Action: isSet(object.Action) ? actionFromJSON(object.Action) : 0,
      Subscription: isSet(object.Subscription) ? Subscription.fromJSON(object.Subscription) : undefined,
    };
  },

  toJSON(message: Subscribe): unknown {
    const obj: any = {};
    if (message.Action !== 0) {
      obj.Action = actionToJSON(message.Action);
    }
    if (message.Subscription !== undefined) {
      obj.Subscription = Subscription.toJSON(message.Subscription);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Subscribe>, I>>(base?: I): Subscribe {
    return Subscribe.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Subscribe>, I>>(object: I): Subscribe {
    const message = createBaseSubscribe();
    message.Action = object.Action ?? 0;
    message.Subscription = (object.Subscription !== undefined && object.Subscription !== null)
      ? Subscription.fromPartial(object.Subscription)
      : undefined;
    return message;
  },
};

function createBaseSubscription(): Subscription {
  return { Method: 0, ID: "", Network: 0, Content: "" };
}

export const Subscription = {
  encode(message: Subscription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Method !== 0) {
      writer.uint32(8).int32(message.Method);
    }
    if (message.ID !== "") {
      writer.uint32(18).string(message.ID);
    }
    if (message.Network !== 0) {
      writer.uint32(24).int32(message.Network);
    }
    if (message.Content !== "") {
      writer.uint32(34).string(message.Content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Subscription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.Method = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Network = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subscription {
    return {
      Method: isSet(object.Method) ? methodFromJSON(object.Method) : 0,
      ID: isSet(object.ID) ? globalThis.String(object.ID) : "",
      Network: isSet(object.Network) ? networkFromJSON(object.Network) : 0,
      Content: isSet(object.Content) ? globalThis.String(object.Content) : "",
    };
  },

  toJSON(message: Subscription): unknown {
    const obj: any = {};
    if (message.Method !== 0) {
      obj.Method = methodToJSON(message.Method);
    }
    if (message.ID !== "") {
      obj.ID = message.ID;
    }
    if (message.Network !== 0) {
      obj.Network = networkToJSON(message.Network);
    }
    if (message.Content !== "") {
      obj.Content = message.Content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Subscription>, I>>(base?: I): Subscription {
    return Subscription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Subscription>, I>>(object: I): Subscription {
    const message = createBaseSubscription();
    message.Method = object.Method ?? 0;
    message.ID = object.ID ?? "";
    message.Network = object.Network ?? 0;
    message.Content = object.Content ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
