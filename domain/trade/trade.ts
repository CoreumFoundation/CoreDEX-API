// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.20.0
// source: domain/trade/trade.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Decimal } from "../decimal/decimal";
import { Denom } from "../denom/denom";
import { MetaData } from "../metadata/metadata";
import { Side, sideFromJSON, sideToJSON } from "../order-properties/order-properties";

export const protobufPackage = "trade";

/** Key in store is TXID-Sequence-Metadata.Network */
export interface Trade {
  Account: string;
  /** User assigned order reference */
  OrderID: string;
  /** The sequence number of the order, assigned by the DEX (guaranteed unique value for the order) */
  Sequence: number;
  Amount: Decimal | undefined;
  Price: number;
  Denom1: Denom | undefined;
  Denom2:
    | Denom
    | undefined;
  /** The buy/sell (e.g. did the user place a buy or sell order) */
  Side: Side;
  /** The time the trade was executed in UTC */
  BlockTime:
    | Date
    | undefined;
  /** Standard storage related fields */
  MetaData: MetaData | undefined;
  TXID?: string | undefined;
  BlockHeight: number;
  /** If the trade has been enriched with precision data */
  Enriched: boolean;
  /** USD representation of the trade values and trading fee (fixed base for easy data comparisson in reports etc) */
  USD?:
    | number
    | undefined;
  /**
   * Trades get stored in alphabetical order of the denom pair.
   * Data is "uninverted" on retrieval and
   * this flag only indicates that the denoms as seen in the record are not in the original order
   */
  Inverted: boolean;
}

export interface Trades {
  Trades: Trade[];
}

export interface TradePair {
  Denom1: Denom | undefined;
  Denom2: Denom | undefined;
  MetaData: MetaData | undefined;
  PriceTick?: Decimal | undefined;
  QuantityStep?: number | undefined;
}

export interface TradePairs {
  TradePairs: TradePair[];
  Offset?: number | undefined;
}

function createBaseTrade(): Trade {
  return {
    Account: "",
    OrderID: "",
    Sequence: 0,
    Amount: undefined,
    Price: 0,
    Denom1: undefined,
    Denom2: undefined,
    Side: 0,
    BlockTime: undefined,
    MetaData: undefined,
    TXID: undefined,
    BlockHeight: 0,
    Enriched: false,
    USD: undefined,
    Inverted: false,
  };
}

export const Trade = {
  encode(message: Trade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Account !== "") {
      writer.uint32(10).string(message.Account);
    }
    if (message.OrderID !== "") {
      writer.uint32(18).string(message.OrderID);
    }
    if (message.Sequence !== 0) {
      writer.uint32(24).int64(message.Sequence);
    }
    if (message.Amount !== undefined) {
      Decimal.encode(message.Amount, writer.uint32(34).fork()).ldelim();
    }
    if (message.Price !== 0) {
      writer.uint32(41).double(message.Price);
    }
    if (message.Denom1 !== undefined) {
      Denom.encode(message.Denom1, writer.uint32(50).fork()).ldelim();
    }
    if (message.Denom2 !== undefined) {
      Denom.encode(message.Denom2, writer.uint32(58).fork()).ldelim();
    }
    if (message.Side !== 0) {
      writer.uint32(64).int32(message.Side);
    }
    if (message.BlockTime !== undefined) {
      Timestamp.encode(toTimestamp(message.BlockTime), writer.uint32(74).fork()).ldelim();
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(242).fork()).ldelim();
    }
    if (message.TXID !== undefined) {
      writer.uint32(250).string(message.TXID);
    }
    if (message.BlockHeight !== 0) {
      writer.uint32(256).int64(message.BlockHeight);
    }
    if (message.Enriched !== false) {
      writer.uint32(264).bool(message.Enriched);
    }
    if (message.USD !== undefined) {
      writer.uint32(325).float(message.USD);
    }
    if (message.Inverted !== false) {
      writer.uint32(400).bool(message.Inverted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Trade {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Account = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.OrderID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Sequence = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Amount = Decimal.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.Price = reader.double();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Denom1 = Denom.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.Denom2 = Denom.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.Side = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.BlockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.TXID = reader.string();
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.BlockHeight = longToNumber(reader.int64() as Long);
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.Enriched = reader.bool();
          continue;
        case 40:
          if (tag !== 325) {
            break;
          }

          message.USD = reader.float();
          continue;
        case 50:
          if (tag !== 400) {
            break;
          }

          message.Inverted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trade {
    return {
      Account: isSet(object.Account) ? globalThis.String(object.Account) : "",
      OrderID: isSet(object.OrderID) ? globalThis.String(object.OrderID) : "",
      Sequence: isSet(object.Sequence) ? globalThis.Number(object.Sequence) : 0,
      Amount: isSet(object.Amount) ? Decimal.fromJSON(object.Amount) : undefined,
      Price: isSet(object.Price) ? globalThis.Number(object.Price) : 0,
      Denom1: isSet(object.Denom1) ? Denom.fromJSON(object.Denom1) : undefined,
      Denom2: isSet(object.Denom2) ? Denom.fromJSON(object.Denom2) : undefined,
      Side: isSet(object.Side) ? sideFromJSON(object.Side) : 0,
      BlockTime: isSet(object.BlockTime) ? fromJsonTimestamp(object.BlockTime) : undefined,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      TXID: isSet(object.TXID) ? globalThis.String(object.TXID) : undefined,
      BlockHeight: isSet(object.BlockHeight) ? globalThis.Number(object.BlockHeight) : 0,
      Enriched: isSet(object.Enriched) ? globalThis.Boolean(object.Enriched) : false,
      USD: isSet(object.USD) ? globalThis.Number(object.USD) : undefined,
      Inverted: isSet(object.Inverted) ? globalThis.Boolean(object.Inverted) : false,
    };
  },

  toJSON(message: Trade): unknown {
    const obj: any = {};
    if (message.Account !== "") {
      obj.Account = message.Account;
    }
    if (message.OrderID !== "") {
      obj.OrderID = message.OrderID;
    }
    if (message.Sequence !== 0) {
      obj.Sequence = Math.round(message.Sequence);
    }
    if (message.Amount !== undefined) {
      obj.Amount = Decimal.toJSON(message.Amount);
    }
    if (message.Price !== 0) {
      obj.Price = message.Price;
    }
    if (message.Denom1 !== undefined) {
      obj.Denom1 = Denom.toJSON(message.Denom1);
    }
    if (message.Denom2 !== undefined) {
      obj.Denom2 = Denom.toJSON(message.Denom2);
    }
    if (message.Side !== 0) {
      obj.Side = sideToJSON(message.Side);
    }
    if (message.BlockTime !== undefined) {
      obj.BlockTime = message.BlockTime.toISOString();
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.TXID !== undefined) {
      obj.TXID = message.TXID;
    }
    if (message.BlockHeight !== 0) {
      obj.BlockHeight = Math.round(message.BlockHeight);
    }
    if (message.Enriched !== false) {
      obj.Enriched = message.Enriched;
    }
    if (message.USD !== undefined) {
      obj.USD = message.USD;
    }
    if (message.Inverted !== false) {
      obj.Inverted = message.Inverted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trade>, I>>(base?: I): Trade {
    return Trade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trade>, I>>(object: I): Trade {
    const message = createBaseTrade();
    message.Account = object.Account ?? "";
    message.OrderID = object.OrderID ?? "";
    message.Sequence = object.Sequence ?? 0;
    message.Amount = (object.Amount !== undefined && object.Amount !== null)
      ? Decimal.fromPartial(object.Amount)
      : undefined;
    message.Price = object.Price ?? 0;
    message.Denom1 = (object.Denom1 !== undefined && object.Denom1 !== null)
      ? Denom.fromPartial(object.Denom1)
      : undefined;
    message.Denom2 = (object.Denom2 !== undefined && object.Denom2 !== null)
      ? Denom.fromPartial(object.Denom2)
      : undefined;
    message.Side = object.Side ?? 0;
    message.BlockTime = object.BlockTime ?? undefined;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.TXID = object.TXID ?? undefined;
    message.BlockHeight = object.BlockHeight ?? 0;
    message.Enriched = object.Enriched ?? false;
    message.USD = object.USD ?? undefined;
    message.Inverted = object.Inverted ?? false;
    return message;
  },
};

function createBaseTrades(): Trades {
  return { Trades: [] };
}

export const Trades = {
  encode(message: Trades, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Trades) {
      Trade.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Trades {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrades();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Trades.push(Trade.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trades {
    return { Trades: globalThis.Array.isArray(object?.Trades) ? object.Trades.map((e: any) => Trade.fromJSON(e)) : [] };
  },

  toJSON(message: Trades): unknown {
    const obj: any = {};
    if (message.Trades?.length) {
      obj.Trades = message.Trades.map((e) => Trade.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trades>, I>>(base?: I): Trades {
    return Trades.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trades>, I>>(object: I): Trades {
    const message = createBaseTrades();
    message.Trades = object.Trades?.map((e) => Trade.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTradePair(): TradePair {
  return { Denom1: undefined, Denom2: undefined, MetaData: undefined, PriceTick: undefined, QuantityStep: undefined };
}

export const TradePair = {
  encode(message: TradePair, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Denom1 !== undefined) {
      Denom.encode(message.Denom1, writer.uint32(10).fork()).ldelim();
    }
    if (message.Denom2 !== undefined) {
      Denom.encode(message.Denom2, writer.uint32(18).fork()).ldelim();
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(26).fork()).ldelim();
    }
    if (message.PriceTick !== undefined) {
      Decimal.encode(message.PriceTick, writer.uint32(34).fork()).ldelim();
    }
    if (message.QuantityStep !== undefined) {
      writer.uint32(40).int64(message.QuantityStep);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradePair {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Denom1 = Denom.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Denom2 = Denom.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.PriceTick = Decimal.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.QuantityStep = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TradePair {
    return {
      Denom1: isSet(object.Denom1) ? Denom.fromJSON(object.Denom1) : undefined,
      Denom2: isSet(object.Denom2) ? Denom.fromJSON(object.Denom2) : undefined,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      PriceTick: isSet(object.PriceTick) ? Decimal.fromJSON(object.PriceTick) : undefined,
      QuantityStep: isSet(object.QuantityStep) ? globalThis.Number(object.QuantityStep) : undefined,
    };
  },

  toJSON(message: TradePair): unknown {
    const obj: any = {};
    if (message.Denom1 !== undefined) {
      obj.Denom1 = Denom.toJSON(message.Denom1);
    }
    if (message.Denom2 !== undefined) {
      obj.Denom2 = Denom.toJSON(message.Denom2);
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.PriceTick !== undefined) {
      obj.PriceTick = Decimal.toJSON(message.PriceTick);
    }
    if (message.QuantityStep !== undefined) {
      obj.QuantityStep = Math.round(message.QuantityStep);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradePair>, I>>(base?: I): TradePair {
    return TradePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradePair>, I>>(object: I): TradePair {
    const message = createBaseTradePair();
    message.Denom1 = (object.Denom1 !== undefined && object.Denom1 !== null)
      ? Denom.fromPartial(object.Denom1)
      : undefined;
    message.Denom2 = (object.Denom2 !== undefined && object.Denom2 !== null)
      ? Denom.fromPartial(object.Denom2)
      : undefined;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.PriceTick = (object.PriceTick !== undefined && object.PriceTick !== null)
      ? Decimal.fromPartial(object.PriceTick)
      : undefined;
    message.QuantityStep = object.QuantityStep ?? undefined;
    return message;
  },
};

function createBaseTradePairs(): TradePairs {
  return { TradePairs: [], Offset: undefined };
}

export const TradePairs = {
  encode(message: TradePairs, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.TradePairs) {
      TradePair.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.Offset !== undefined) {
      writer.uint32(16).int32(message.Offset);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradePairs {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradePairs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.TradePairs.push(TradePair.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Offset = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TradePairs {
    return {
      TradePairs: globalThis.Array.isArray(object?.TradePairs)
        ? object.TradePairs.map((e: any) => TradePair.fromJSON(e))
        : [],
      Offset: isSet(object.Offset) ? globalThis.Number(object.Offset) : undefined,
    };
  },

  toJSON(message: TradePairs): unknown {
    const obj: any = {};
    if (message.TradePairs?.length) {
      obj.TradePairs = message.TradePairs.map((e) => TradePair.toJSON(e));
    }
    if (message.Offset !== undefined) {
      obj.Offset = Math.round(message.Offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradePairs>, I>>(base?: I): TradePairs {
    return TradePairs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradePairs>, I>>(object: I): TradePairs {
    const message = createBaseTradePairs();
    message.TradePairs = object.TradePairs?.map((e) => TradePair.fromPartial(e)) || [];
    message.Offset = object.Offset ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
