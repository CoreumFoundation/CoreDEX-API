// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: domain/order/order.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Decimal } from "../decimal/decimal";
import { Denom } from "../denom/denom";
import { MetaData } from "../metadata/metadata";
import { Side, sideFromJSON, sideToJSON } from "../order-properties/order-properties";

export const protobufPackage = "order";

/** Type is order type. */
export enum OrderType {
  /** ORDER_TYPE_UNSPECIFIED - order_type_unspecified reserves the default value, to protect against unexpected settings. */
  ORDER_TYPE_UNSPECIFIED = 0,
  /** ORDER_TYPE_LIMIT - order_type_limit means that the order is limit order. */
  ORDER_TYPE_LIMIT = 1,
  /** ORDER_TYPE_MARKET - limit order_type_market that the order is market order. */
  ORDER_TYPE_MARKET = 2,
  UNRECOGNIZED = -1,
}

export function orderTypeFromJSON(object: any): OrderType {
  switch (object) {
    case 0:
    case "ORDER_TYPE_UNSPECIFIED":
      return OrderType.ORDER_TYPE_UNSPECIFIED;
    case 1:
    case "ORDER_TYPE_LIMIT":
      return OrderType.ORDER_TYPE_LIMIT;
    case 2:
    case "ORDER_TYPE_MARKET":
      return OrderType.ORDER_TYPE_MARKET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderType.UNRECOGNIZED;
  }
}

export function orderTypeToJSON(object: OrderType): string {
  switch (object) {
    case OrderType.ORDER_TYPE_UNSPECIFIED:
      return "ORDER_TYPE_UNSPECIFIED";
    case OrderType.ORDER_TYPE_LIMIT:
      return "ORDER_TYPE_LIMIT";
    case OrderType.ORDER_TYPE_MARKET:
      return "ORDER_TYPE_MARKET";
    case OrderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TimeInForce is order time in force. */
export enum TimeInForce {
  /** TIME_IN_FORCE_UNSPECIFIED - time_in_force_unspecified reserves the default value, to protect against unexpected settings. */
  TIME_IN_FORCE_UNSPECIFIED = 0,
  /** TIME_IN_FORCE_GTC - time_in_force_gtc means that the order remains active until it is fully executed or manually canceled. */
  TIME_IN_FORCE_GTC = 1,
  /**
   * TIME_IN_FORCE_IOC - time_in_force_ioc  means that order must be executed immediately, either in full or partially. Any portion of the
   *  order that cannot be filled immediately is canceled.
   */
  TIME_IN_FORCE_IOC = 2,
  /** TIME_IN_FORCE_FOK - time_in_force_fok means that order must be fully executed or canceled. */
  TIME_IN_FORCE_FOK = 3,
  UNRECOGNIZED = -1,
}

export function timeInForceFromJSON(object: any): TimeInForce {
  switch (object) {
    case 0:
    case "TIME_IN_FORCE_UNSPECIFIED":
      return TimeInForce.TIME_IN_FORCE_UNSPECIFIED;
    case 1:
    case "TIME_IN_FORCE_GTC":
      return TimeInForce.TIME_IN_FORCE_GTC;
    case 2:
    case "TIME_IN_FORCE_IOC":
      return TimeInForce.TIME_IN_FORCE_IOC;
    case 3:
    case "TIME_IN_FORCE_FOK":
      return TimeInForce.TIME_IN_FORCE_FOK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TimeInForce.UNRECOGNIZED;
  }
}

export function timeInForceToJSON(object: TimeInForce): string {
  switch (object) {
    case TimeInForce.TIME_IN_FORCE_UNSPECIFIED:
      return "TIME_IN_FORCE_UNSPECIFIED";
    case TimeInForce.TIME_IN_FORCE_GTC:
      return "TIME_IN_FORCE_GTC";
    case TimeInForce.TIME_IN_FORCE_IOC:
      return "TIME_IN_FORCE_IOC";
    case TimeInForce.TIME_IN_FORCE_FOK:
      return "TIME_IN_FORCE_FOK";
    case TimeInForce.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderStatus {
  /** ORDER_STATUS_UNSPECIFIED - order_status_unspecified reserves the default value, to protect against unexpected settings. */
  ORDER_STATUS_UNSPECIFIED = 0,
  /** ORDER_STATUS_OPEN - order_status_open means that the order is open with any remaining quantity */
  ORDER_STATUS_OPEN = 1,
  /** ORDER_STATUS_CANCELED - order_status_cancelled means the user has canceled the order. */
  ORDER_STATUS_CANCELED = 2,
  /** ORDER_STATUS_FILLED - order_status_filled means that the order is filled (quantity remaining is 0) */
  ORDER_STATUS_FILLED = 3,
  /** ORDER_STATUS_EXPIRED - order_status_expired means that the order is expired (e.g. a block event has passed the good til block height/time). */
  ORDER_STATUS_EXPIRED = 4,
  UNRECOGNIZED = -1,
}

export function orderStatusFromJSON(object: any): OrderStatus {
  switch (object) {
    case 0:
    case "ORDER_STATUS_UNSPECIFIED":
      return OrderStatus.ORDER_STATUS_UNSPECIFIED;
    case 1:
    case "ORDER_STATUS_OPEN":
      return OrderStatus.ORDER_STATUS_OPEN;
    case 2:
    case "ORDER_STATUS_CANCELED":
      return OrderStatus.ORDER_STATUS_CANCELED;
    case 3:
    case "ORDER_STATUS_FILLED":
      return OrderStatus.ORDER_STATUS_FILLED;
    case 4:
    case "ORDER_STATUS_EXPIRED":
      return OrderStatus.ORDER_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderStatus.UNRECOGNIZED;
  }
}

export function orderStatusToJSON(object: OrderStatus): string {
  switch (object) {
    case OrderStatus.ORDER_STATUS_UNSPECIFIED:
      return "ORDER_STATUS_UNSPECIFIED";
    case OrderStatus.ORDER_STATUS_OPEN:
      return "ORDER_STATUS_OPEN";
    case OrderStatus.ORDER_STATUS_CANCELED:
      return "ORDER_STATUS_CANCELED";
    case OrderStatus.ORDER_STATUS_FILLED:
      return "ORDER_STATUS_FILLED";
    case OrderStatus.ORDER_STATUS_EXPIRED:
      return "ORDER_STATUS_EXPIRED";
    case OrderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Unique key is Sequence-Network */
export interface Order {
  /** account is order creator address. */
  Account: string;
  Type: OrderType;
  OrderID: string;
  /** Sequence ID */
  Sequence: number;
  BaseDenom: Denom | undefined;
  QuoteDenom:
    | Denom
    | undefined;
  /** price is value of one unit of the BaseDenom expressed in terms of the QuoteDenom. */
  Price: number;
  /** quantity is amount of the base BaseDenom being traded. */
  Quantity: Decimal | undefined;
  RemainingQuantity:
    | Decimal
    | undefined;
  /** Buy or sell */
  Side: Side;
  GoodTil: GoodTil | undefined;
  TimeInForce: TimeInForce;
  /** Time the order was created on chain. This can differ from metadata.CreatedAt which signifies when the record was created in the database */
  BlockTime:
    | Date
    | undefined;
  /** Maintain the status of the order (tracked for user intent clarification) */
  OrderStatus: OrderStatus;
  OrderFee: number;
  MetaData: MetaData | undefined;
  TXID?: string | undefined;
  BlockHeight: number;
  /** If the order has been enriched with precision data */
  Enriched: boolean;
}

/** GoodTil is a good til order settings. */
export interface GoodTil {
  /** good_til_block_height means that order remains active until a specific blockchain block height is reached. */
  BlockHeight: number;
  /** good_til_block_time means that order remains active until a specific blockchain block time is reached. */
  BlockTime: Date | undefined;
}

export interface Orders {
  Orders: Order[];
  Offset?: number | undefined;
}

function createBaseOrder(): Order {
  return {
    Account: "",
    Type: 0,
    OrderID: "",
    Sequence: 0,
    BaseDenom: undefined,
    QuoteDenom: undefined,
    Price: 0,
    Quantity: undefined,
    RemainingQuantity: undefined,
    Side: 0,
    GoodTil: undefined,
    TimeInForce: 0,
    BlockTime: undefined,
    OrderStatus: 0,
    OrderFee: 0,
    MetaData: undefined,
    TXID: undefined,
    BlockHeight: 0,
    Enriched: false,
  };
}

export const Order = {
  encode(message: Order, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Account !== "") {
      writer.uint32(10).string(message.Account);
    }
    if (message.Type !== 0) {
      writer.uint32(16).int32(message.Type);
    }
    if (message.OrderID !== "") {
      writer.uint32(26).string(message.OrderID);
    }
    if (message.Sequence !== 0) {
      writer.uint32(32).int64(message.Sequence);
    }
    if (message.BaseDenom !== undefined) {
      Denom.encode(message.BaseDenom, writer.uint32(42).fork()).ldelim();
    }
    if (message.QuoteDenom !== undefined) {
      Denom.encode(message.QuoteDenom, writer.uint32(50).fork()).ldelim();
    }
    if (message.Price !== 0) {
      writer.uint32(57).double(message.Price);
    }
    if (message.Quantity !== undefined) {
      Decimal.encode(message.Quantity, writer.uint32(66).fork()).ldelim();
    }
    if (message.RemainingQuantity !== undefined) {
      Decimal.encode(message.RemainingQuantity, writer.uint32(74).fork()).ldelim();
    }
    if (message.Side !== 0) {
      writer.uint32(80).int32(message.Side);
    }
    if (message.GoodTil !== undefined) {
      GoodTil.encode(message.GoodTil, writer.uint32(90).fork()).ldelim();
    }
    if (message.TimeInForce !== 0) {
      writer.uint32(96).int32(message.TimeInForce);
    }
    if (message.BlockTime !== undefined) {
      Timestamp.encode(toTimestamp(message.BlockTime), writer.uint32(106).fork()).ldelim();
    }
    if (message.OrderStatus !== 0) {
      writer.uint32(112).int32(message.OrderStatus);
    }
    if (message.OrderFee !== 0) {
      writer.uint32(120).int64(message.OrderFee);
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(162).fork()).ldelim();
    }
    if (message.TXID !== undefined) {
      writer.uint32(170).string(message.TXID);
    }
    if (message.BlockHeight !== 0) {
      writer.uint32(176).int64(message.BlockHeight);
    }
    if (message.Enriched !== false) {
      writer.uint32(184).bool(message.Enriched);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Order {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Account = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.OrderID = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.Sequence = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.BaseDenom = Denom.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.QuoteDenom = Denom.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.Price = reader.double();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.Quantity = Decimal.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.RemainingQuantity = Decimal.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.Side = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.GoodTil = GoodTil.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.TimeInForce = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.BlockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.OrderStatus = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.OrderFee = longToNumber(reader.int64() as Long);
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.TXID = reader.string();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.BlockHeight = longToNumber(reader.int64() as Long);
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.Enriched = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      Account: isSet(object.Account) ? globalThis.String(object.Account) : "",
      Type: isSet(object.Type) ? orderTypeFromJSON(object.Type) : 0,
      OrderID: isSet(object.OrderID) ? globalThis.String(object.OrderID) : "",
      Sequence: isSet(object.Sequence) ? globalThis.Number(object.Sequence) : 0,
      BaseDenom: isSet(object.BaseDenom) ? Denom.fromJSON(object.BaseDenom) : undefined,
      QuoteDenom: isSet(object.QuoteDenom) ? Denom.fromJSON(object.QuoteDenom) : undefined,
      Price: isSet(object.Price) ? globalThis.Number(object.Price) : 0,
      Quantity: isSet(object.Quantity) ? Decimal.fromJSON(object.Quantity) : undefined,
      RemainingQuantity: isSet(object.RemainingQuantity) ? Decimal.fromJSON(object.RemainingQuantity) : undefined,
      Side: isSet(object.Side) ? sideFromJSON(object.Side) : 0,
      GoodTil: isSet(object.GoodTil) ? GoodTil.fromJSON(object.GoodTil) : undefined,
      TimeInForce: isSet(object.TimeInForce) ? timeInForceFromJSON(object.TimeInForce) : 0,
      BlockTime: isSet(object.BlockTime) ? fromJsonTimestamp(object.BlockTime) : undefined,
      OrderStatus: isSet(object.OrderStatus) ? orderStatusFromJSON(object.OrderStatus) : 0,
      OrderFee: isSet(object.OrderFee) ? globalThis.Number(object.OrderFee) : 0,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      TXID: isSet(object.TXID) ? globalThis.String(object.TXID) : undefined,
      BlockHeight: isSet(object.BlockHeight) ? globalThis.Number(object.BlockHeight) : 0,
      Enriched: isSet(object.Enriched) ? globalThis.Boolean(object.Enriched) : false,
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.Account !== "") {
      obj.Account = message.Account;
    }
    if (message.Type !== 0) {
      obj.Type = orderTypeToJSON(message.Type);
    }
    if (message.OrderID !== "") {
      obj.OrderID = message.OrderID;
    }
    if (message.Sequence !== 0) {
      obj.Sequence = Math.round(message.Sequence);
    }
    if (message.BaseDenom !== undefined) {
      obj.BaseDenom = Denom.toJSON(message.BaseDenom);
    }
    if (message.QuoteDenom !== undefined) {
      obj.QuoteDenom = Denom.toJSON(message.QuoteDenom);
    }
    if (message.Price !== 0) {
      obj.Price = message.Price;
    }
    if (message.Quantity !== undefined) {
      obj.Quantity = Decimal.toJSON(message.Quantity);
    }
    if (message.RemainingQuantity !== undefined) {
      obj.RemainingQuantity = Decimal.toJSON(message.RemainingQuantity);
    }
    if (message.Side !== 0) {
      obj.Side = sideToJSON(message.Side);
    }
    if (message.GoodTil !== undefined) {
      obj.GoodTil = GoodTil.toJSON(message.GoodTil);
    }
    if (message.TimeInForce !== 0) {
      obj.TimeInForce = timeInForceToJSON(message.TimeInForce);
    }
    if (message.BlockTime !== undefined) {
      obj.BlockTime = message.BlockTime.toISOString();
    }
    if (message.OrderStatus !== 0) {
      obj.OrderStatus = orderStatusToJSON(message.OrderStatus);
    }
    if (message.OrderFee !== 0) {
      obj.OrderFee = Math.round(message.OrderFee);
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.TXID !== undefined) {
      obj.TXID = message.TXID;
    }
    if (message.BlockHeight !== 0) {
      obj.BlockHeight = Math.round(message.BlockHeight);
    }
    if (message.Enriched !== false) {
      obj.Enriched = message.Enriched;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Order>, I>>(base?: I): Order {
    return Order.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Order>, I>>(object: I): Order {
    const message = createBaseOrder();
    message.Account = object.Account ?? "";
    message.Type = object.Type ?? 0;
    message.OrderID = object.OrderID ?? "";
    message.Sequence = object.Sequence ?? 0;
    message.BaseDenom = (object.BaseDenom !== undefined && object.BaseDenom !== null)
      ? Denom.fromPartial(object.BaseDenom)
      : undefined;
    message.QuoteDenom = (object.QuoteDenom !== undefined && object.QuoteDenom !== null)
      ? Denom.fromPartial(object.QuoteDenom)
      : undefined;
    message.Price = object.Price ?? 0;
    message.Quantity = (object.Quantity !== undefined && object.Quantity !== null)
      ? Decimal.fromPartial(object.Quantity)
      : undefined;
    message.RemainingQuantity = (object.RemainingQuantity !== undefined && object.RemainingQuantity !== null)
      ? Decimal.fromPartial(object.RemainingQuantity)
      : undefined;
    message.Side = object.Side ?? 0;
    message.GoodTil = (object.GoodTil !== undefined && object.GoodTil !== null)
      ? GoodTil.fromPartial(object.GoodTil)
      : undefined;
    message.TimeInForce = object.TimeInForce ?? 0;
    message.BlockTime = object.BlockTime ?? undefined;
    message.OrderStatus = object.OrderStatus ?? 0;
    message.OrderFee = object.OrderFee ?? 0;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.TXID = object.TXID ?? undefined;
    message.BlockHeight = object.BlockHeight ?? 0;
    message.Enriched = object.Enriched ?? false;
    return message;
  },
};

function createBaseGoodTil(): GoodTil {
  return { BlockHeight: 0, BlockTime: undefined };
}

export const GoodTil = {
  encode(message: GoodTil, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.BlockHeight !== 0) {
      writer.uint32(8).int64(message.BlockHeight);
    }
    if (message.BlockTime !== undefined) {
      Timestamp.encode(toTimestamp(message.BlockTime), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GoodTil {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoodTil();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.BlockHeight = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.BlockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoodTil {
    return {
      BlockHeight: isSet(object.BlockHeight) ? globalThis.Number(object.BlockHeight) : 0,
      BlockTime: isSet(object.BlockTime) ? fromJsonTimestamp(object.BlockTime) : undefined,
    };
  },

  toJSON(message: GoodTil): unknown {
    const obj: any = {};
    if (message.BlockHeight !== 0) {
      obj.BlockHeight = Math.round(message.BlockHeight);
    }
    if (message.BlockTime !== undefined) {
      obj.BlockTime = message.BlockTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoodTil>, I>>(base?: I): GoodTil {
    return GoodTil.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoodTil>, I>>(object: I): GoodTil {
    const message = createBaseGoodTil();
    message.BlockHeight = object.BlockHeight ?? 0;
    message.BlockTime = object.BlockTime ?? undefined;
    return message;
  },
};

function createBaseOrders(): Orders {
  return { Orders: [], Offset: undefined };
}

export const Orders = {
  encode(message: Orders, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Orders) {
      Order.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.Offset !== undefined) {
      writer.uint32(16).int32(message.Offset);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Orders {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Orders.push(Order.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Offset = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Orders {
    return {
      Orders: globalThis.Array.isArray(object?.Orders) ? object.Orders.map((e: any) => Order.fromJSON(e)) : [],
      Offset: isSet(object.Offset) ? globalThis.Number(object.Offset) : undefined,
    };
  },

  toJSON(message: Orders): unknown {
    const obj: any = {};
    if (message.Orders?.length) {
      obj.Orders = message.Orders.map((e) => Order.toJSON(e));
    }
    if (message.Offset !== undefined) {
      obj.Offset = Math.round(message.Offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Orders>, I>>(base?: I): Orders {
    return Orders.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Orders>, I>>(object: I): Orders {
    const message = createBaseOrders();
    message.Orders = object.Orders?.map((e) => Order.fromPartial(e)) || [];
    message.Offset = object.Offset ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
