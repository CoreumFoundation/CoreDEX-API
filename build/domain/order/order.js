// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: domain/order/order.proto
/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Decimal } from "../decimal/decimal";
import { Denom } from "../denom/denom";
import { MetaData } from "../metadata/metadata";
import { sideFromJSON, sideToJSON } from "../order-properties/order-properties";
export const protobufPackage = "order";
/** Type is order type. */
export var OrderType;
(function (OrderType) {
    /** ORDER_TYPE_UNSPECIFIED - order_type_unspecified reserves the default value, to protect against unexpected settings. */
    OrderType[OrderType["ORDER_TYPE_UNSPECIFIED"] = 0] = "ORDER_TYPE_UNSPECIFIED";
    /** ORDER_TYPE_LIMIT - order_type_limit means that the order is limit order. */
    OrderType[OrderType["ORDER_TYPE_LIMIT"] = 1] = "ORDER_TYPE_LIMIT";
    /** ORDER_TYPE_MARKET - limit order_type_market that the order is market order. */
    OrderType[OrderType["ORDER_TYPE_MARKET"] = 2] = "ORDER_TYPE_MARKET";
    OrderType[OrderType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderType || (OrderType = {}));
export function orderTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "ORDER_TYPE_UNSPECIFIED":
            return OrderType.ORDER_TYPE_UNSPECIFIED;
        case 1:
        case "ORDER_TYPE_LIMIT":
            return OrderType.ORDER_TYPE_LIMIT;
        case 2:
        case "ORDER_TYPE_MARKET":
            return OrderType.ORDER_TYPE_MARKET;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OrderType.UNRECOGNIZED;
    }
}
export function orderTypeToJSON(object) {
    switch (object) {
        case OrderType.ORDER_TYPE_UNSPECIFIED:
            return "ORDER_TYPE_UNSPECIFIED";
        case OrderType.ORDER_TYPE_LIMIT:
            return "ORDER_TYPE_LIMIT";
        case OrderType.ORDER_TYPE_MARKET:
            return "ORDER_TYPE_MARKET";
        case OrderType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/** TimeInForce is order time in force. */
export var TimeInForce;
(function (TimeInForce) {
    /** TIME_IN_FORCE_UNSPECIFIED - time_in_force_unspecified reserves the default value, to protect against unexpected settings. */
    TimeInForce[TimeInForce["TIME_IN_FORCE_UNSPECIFIED"] = 0] = "TIME_IN_FORCE_UNSPECIFIED";
    /** TIME_IN_FORCE_GTC - time_in_force_gtc means that the order remains active until it is fully executed or manually canceled. */
    TimeInForce[TimeInForce["TIME_IN_FORCE_GTC"] = 1] = "TIME_IN_FORCE_GTC";
    /**
     * TIME_IN_FORCE_IOC - time_in_force_ioc  means that order must be executed immediately, either in full or partially. Any portion of the
     *  order that cannot be filled immediately is canceled.
     */
    TimeInForce[TimeInForce["TIME_IN_FORCE_IOC"] = 2] = "TIME_IN_FORCE_IOC";
    /** TIME_IN_FORCE_FOK - time_in_force_fok means that order must be fully executed or canceled. */
    TimeInForce[TimeInForce["TIME_IN_FORCE_FOK"] = 3] = "TIME_IN_FORCE_FOK";
    TimeInForce[TimeInForce["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TimeInForce || (TimeInForce = {}));
export function timeInForceFromJSON(object) {
    switch (object) {
        case 0:
        case "TIME_IN_FORCE_UNSPECIFIED":
            return TimeInForce.TIME_IN_FORCE_UNSPECIFIED;
        case 1:
        case "TIME_IN_FORCE_GTC":
            return TimeInForce.TIME_IN_FORCE_GTC;
        case 2:
        case "TIME_IN_FORCE_IOC":
            return TimeInForce.TIME_IN_FORCE_IOC;
        case 3:
        case "TIME_IN_FORCE_FOK":
            return TimeInForce.TIME_IN_FORCE_FOK;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TimeInForce.UNRECOGNIZED;
    }
}
export function timeInForceToJSON(object) {
    switch (object) {
        case TimeInForce.TIME_IN_FORCE_UNSPECIFIED:
            return "TIME_IN_FORCE_UNSPECIFIED";
        case TimeInForce.TIME_IN_FORCE_GTC:
            return "TIME_IN_FORCE_GTC";
        case TimeInForce.TIME_IN_FORCE_IOC:
            return "TIME_IN_FORCE_IOC";
        case TimeInForce.TIME_IN_FORCE_FOK:
            return "TIME_IN_FORCE_FOK";
        case TimeInForce.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var OrderStatus;
(function (OrderStatus) {
    /** ORDER_STATUS_UNSPECIFIED - order_status_unspecified reserves the default value, to protect against unexpected settings. */
    OrderStatus[OrderStatus["ORDER_STATUS_UNSPECIFIED"] = 0] = "ORDER_STATUS_UNSPECIFIED";
    /** ORDER_STATUS_OPEN - order_status_open means that the order is open with any remaining quantity */
    OrderStatus[OrderStatus["ORDER_STATUS_OPEN"] = 1] = "ORDER_STATUS_OPEN";
    /** ORDER_STATUS_CANCELED - order_status_cancelled means the user has canceled the order. */
    OrderStatus[OrderStatus["ORDER_STATUS_CANCELED"] = 2] = "ORDER_STATUS_CANCELED";
    /** ORDER_STATUS_FILLED - order_status_filled means that the order is filled (quantity remaining is 0) */
    OrderStatus[OrderStatus["ORDER_STATUS_FILLED"] = 3] = "ORDER_STATUS_FILLED";
    /** ORDER_STATUS_EXPIRED - order_status_expired means that the order is expired (e.g. a block event has passed the good til block height/time). */
    OrderStatus[OrderStatus["ORDER_STATUS_EXPIRED"] = 4] = "ORDER_STATUS_EXPIRED";
    OrderStatus[OrderStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderStatus || (OrderStatus = {}));
export function orderStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "ORDER_STATUS_UNSPECIFIED":
            return OrderStatus.ORDER_STATUS_UNSPECIFIED;
        case 1:
        case "ORDER_STATUS_OPEN":
            return OrderStatus.ORDER_STATUS_OPEN;
        case 2:
        case "ORDER_STATUS_CANCELED":
            return OrderStatus.ORDER_STATUS_CANCELED;
        case 3:
        case "ORDER_STATUS_FILLED":
            return OrderStatus.ORDER_STATUS_FILLED;
        case 4:
        case "ORDER_STATUS_EXPIRED":
            return OrderStatus.ORDER_STATUS_EXPIRED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OrderStatus.UNRECOGNIZED;
    }
}
export function orderStatusToJSON(object) {
    switch (object) {
        case OrderStatus.ORDER_STATUS_UNSPECIFIED:
            return "ORDER_STATUS_UNSPECIFIED";
        case OrderStatus.ORDER_STATUS_OPEN:
            return "ORDER_STATUS_OPEN";
        case OrderStatus.ORDER_STATUS_CANCELED:
            return "ORDER_STATUS_CANCELED";
        case OrderStatus.ORDER_STATUS_FILLED:
            return "ORDER_STATUS_FILLED";
        case OrderStatus.ORDER_STATUS_EXPIRED:
            return "ORDER_STATUS_EXPIRED";
        case OrderStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseOrder() {
    return {
        Account: "",
        Type: 0,
        OrderID: "",
        Sequence: 0,
        BaseDenom: undefined,
        QuoteDenom: undefined,
        Price: 0,
        Quantity: undefined,
        RemainingQuantity: undefined,
        Side: 0,
        GoodTil: undefined,
        TimeInForce: 0,
        BlockTime: undefined,
        OrderStatus: 0,
        OrderFee: 0,
        MetaData: undefined,
        TXID: undefined,
        BlockHeight: 0,
        Enriched: false,
    };
}
export const Order = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.Account !== "") {
            writer.uint32(10).string(message.Account);
        }
        if (message.Type !== 0) {
            writer.uint32(16).int32(message.Type);
        }
        if (message.OrderID !== "") {
            writer.uint32(26).string(message.OrderID);
        }
        if (message.Sequence !== 0) {
            writer.uint32(32).int64(message.Sequence);
        }
        if (message.BaseDenom !== undefined) {
            Denom.encode(message.BaseDenom, writer.uint32(42).fork()).ldelim();
        }
        if (message.QuoteDenom !== undefined) {
            Denom.encode(message.QuoteDenom, writer.uint32(50).fork()).ldelim();
        }
        if (message.Price !== 0) {
            writer.uint32(57).double(message.Price);
        }
        if (message.Quantity !== undefined) {
            Decimal.encode(message.Quantity, writer.uint32(66).fork()).ldelim();
        }
        if (message.RemainingQuantity !== undefined) {
            Decimal.encode(message.RemainingQuantity, writer.uint32(74).fork()).ldelim();
        }
        if (message.Side !== 0) {
            writer.uint32(80).int32(message.Side);
        }
        if (message.GoodTil !== undefined) {
            GoodTil.encode(message.GoodTil, writer.uint32(90).fork()).ldelim();
        }
        if (message.TimeInForce !== 0) {
            writer.uint32(96).int32(message.TimeInForce);
        }
        if (message.BlockTime !== undefined) {
            Timestamp.encode(toTimestamp(message.BlockTime), writer.uint32(106).fork()).ldelim();
        }
        if (message.OrderStatus !== 0) {
            writer.uint32(112).int32(message.OrderStatus);
        }
        if (message.OrderFee !== 0) {
            writer.uint32(120).int64(message.OrderFee);
        }
        if (message.MetaData !== undefined) {
            MetaData.encode(message.MetaData, writer.uint32(162).fork()).ldelim();
        }
        if (message.TXID !== undefined) {
            writer.uint32(170).string(message.TXID);
        }
        if (message.BlockHeight !== 0) {
            writer.uint32(176).int64(message.BlockHeight);
        }
        if (message.Enriched !== false) {
            writer.uint32(184).bool(message.Enriched);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrder();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.Account = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.Type = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.OrderID = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.Sequence = longToNumber(reader.int64());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.BaseDenom = Denom.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.QuoteDenom = Denom.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 57) {
                        break;
                    }
                    message.Price = reader.double();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.Quantity = Decimal.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.RemainingQuantity = Decimal.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 80) {
                        break;
                    }
                    message.Side = reader.int32();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.GoodTil = GoodTil.decode(reader, reader.uint32());
                    continue;
                case 12:
                    if (tag !== 96) {
                        break;
                    }
                    message.TimeInForce = reader.int32();
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.BlockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 14:
                    if (tag !== 112) {
                        break;
                    }
                    message.OrderStatus = reader.int32();
                    continue;
                case 15:
                    if (tag !== 120) {
                        break;
                    }
                    message.OrderFee = longToNumber(reader.int64());
                    continue;
                case 20:
                    if (tag !== 162) {
                        break;
                    }
                    message.MetaData = MetaData.decode(reader, reader.uint32());
                    continue;
                case 21:
                    if (tag !== 170) {
                        break;
                    }
                    message.TXID = reader.string();
                    continue;
                case 22:
                    if (tag !== 176) {
                        break;
                    }
                    message.BlockHeight = longToNumber(reader.int64());
                    continue;
                case 23:
                    if (tag !== 184) {
                        break;
                    }
                    message.Enriched = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Account: isSet(object.Account) ? globalThis.String(object.Account) : "",
            Type: isSet(object.Type) ? orderTypeFromJSON(object.Type) : 0,
            OrderID: isSet(object.OrderID) ? globalThis.String(object.OrderID) : "",
            Sequence: isSet(object.Sequence) ? globalThis.Number(object.Sequence) : 0,
            BaseDenom: isSet(object.BaseDenom) ? Denom.fromJSON(object.BaseDenom) : undefined,
            QuoteDenom: isSet(object.QuoteDenom) ? Denom.fromJSON(object.QuoteDenom) : undefined,
            Price: isSet(object.Price) ? globalThis.Number(object.Price) : 0,
            Quantity: isSet(object.Quantity) ? Decimal.fromJSON(object.Quantity) : undefined,
            RemainingQuantity: isSet(object.RemainingQuantity) ? Decimal.fromJSON(object.RemainingQuantity) : undefined,
            Side: isSet(object.Side) ? sideFromJSON(object.Side) : 0,
            GoodTil: isSet(object.GoodTil) ? GoodTil.fromJSON(object.GoodTil) : undefined,
            TimeInForce: isSet(object.TimeInForce) ? timeInForceFromJSON(object.TimeInForce) : 0,
            BlockTime: isSet(object.BlockTime) ? fromJsonTimestamp(object.BlockTime) : undefined,
            OrderStatus: isSet(object.OrderStatus) ? orderStatusFromJSON(object.OrderStatus) : 0,
            OrderFee: isSet(object.OrderFee) ? globalThis.Number(object.OrderFee) : 0,
            MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
            TXID: isSet(object.TXID) ? globalThis.String(object.TXID) : undefined,
            BlockHeight: isSet(object.BlockHeight) ? globalThis.Number(object.BlockHeight) : 0,
            Enriched: isSet(object.Enriched) ? globalThis.Boolean(object.Enriched) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.Account !== "") {
            obj.Account = message.Account;
        }
        if (message.Type !== 0) {
            obj.Type = orderTypeToJSON(message.Type);
        }
        if (message.OrderID !== "") {
            obj.OrderID = message.OrderID;
        }
        if (message.Sequence !== 0) {
            obj.Sequence = Math.round(message.Sequence);
        }
        if (message.BaseDenom !== undefined) {
            obj.BaseDenom = Denom.toJSON(message.BaseDenom);
        }
        if (message.QuoteDenom !== undefined) {
            obj.QuoteDenom = Denom.toJSON(message.QuoteDenom);
        }
        if (message.Price !== 0) {
            obj.Price = message.Price;
        }
        if (message.Quantity !== undefined) {
            obj.Quantity = Decimal.toJSON(message.Quantity);
        }
        if (message.RemainingQuantity !== undefined) {
            obj.RemainingQuantity = Decimal.toJSON(message.RemainingQuantity);
        }
        if (message.Side !== 0) {
            obj.Side = sideToJSON(message.Side);
        }
        if (message.GoodTil !== undefined) {
            obj.GoodTil = GoodTil.toJSON(message.GoodTil);
        }
        if (message.TimeInForce !== 0) {
            obj.TimeInForce = timeInForceToJSON(message.TimeInForce);
        }
        if (message.BlockTime !== undefined) {
            obj.BlockTime = message.BlockTime.toISOString();
        }
        if (message.OrderStatus !== 0) {
            obj.OrderStatus = orderStatusToJSON(message.OrderStatus);
        }
        if (message.OrderFee !== 0) {
            obj.OrderFee = Math.round(message.OrderFee);
        }
        if (message.MetaData !== undefined) {
            obj.MetaData = MetaData.toJSON(message.MetaData);
        }
        if (message.TXID !== undefined) {
            obj.TXID = message.TXID;
        }
        if (message.BlockHeight !== 0) {
            obj.BlockHeight = Math.round(message.BlockHeight);
        }
        if (message.Enriched !== false) {
            obj.Enriched = message.Enriched;
        }
        return obj;
    },
    create(base) {
        return Order.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const message = createBaseOrder();
        message.Account = (_a = object.Account) !== null && _a !== void 0 ? _a : "";
        message.Type = (_b = object.Type) !== null && _b !== void 0 ? _b : 0;
        message.OrderID = (_c = object.OrderID) !== null && _c !== void 0 ? _c : "";
        message.Sequence = (_d = object.Sequence) !== null && _d !== void 0 ? _d : 0;
        message.BaseDenom = (object.BaseDenom !== undefined && object.BaseDenom !== null)
            ? Denom.fromPartial(object.BaseDenom)
            : undefined;
        message.QuoteDenom = (object.QuoteDenom !== undefined && object.QuoteDenom !== null)
            ? Denom.fromPartial(object.QuoteDenom)
            : undefined;
        message.Price = (_e = object.Price) !== null && _e !== void 0 ? _e : 0;
        message.Quantity = (object.Quantity !== undefined && object.Quantity !== null)
            ? Decimal.fromPartial(object.Quantity)
            : undefined;
        message.RemainingQuantity = (object.RemainingQuantity !== undefined && object.RemainingQuantity !== null)
            ? Decimal.fromPartial(object.RemainingQuantity)
            : undefined;
        message.Side = (_f = object.Side) !== null && _f !== void 0 ? _f : 0;
        message.GoodTil = (object.GoodTil !== undefined && object.GoodTil !== null)
            ? GoodTil.fromPartial(object.GoodTil)
            : undefined;
        message.TimeInForce = (_g = object.TimeInForce) !== null && _g !== void 0 ? _g : 0;
        message.BlockTime = (_h = object.BlockTime) !== null && _h !== void 0 ? _h : undefined;
        message.OrderStatus = (_j = object.OrderStatus) !== null && _j !== void 0 ? _j : 0;
        message.OrderFee = (_k = object.OrderFee) !== null && _k !== void 0 ? _k : 0;
        message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
            ? MetaData.fromPartial(object.MetaData)
            : undefined;
        message.TXID = (_l = object.TXID) !== null && _l !== void 0 ? _l : undefined;
        message.BlockHeight = (_m = object.BlockHeight) !== null && _m !== void 0 ? _m : 0;
        message.Enriched = (_o = object.Enriched) !== null && _o !== void 0 ? _o : false;
        return message;
    },
};
function createBaseGoodTil() {
    return { BlockHeight: 0, BlockTime: undefined };
}
export const GoodTil = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.BlockHeight !== 0) {
            writer.uint32(8).int64(message.BlockHeight);
        }
        if (message.BlockTime !== undefined) {
            Timestamp.encode(toTimestamp(message.BlockTime), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGoodTil();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.BlockHeight = longToNumber(reader.int64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.BlockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            BlockHeight: isSet(object.BlockHeight) ? globalThis.Number(object.BlockHeight) : 0,
            BlockTime: isSet(object.BlockTime) ? fromJsonTimestamp(object.BlockTime) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.BlockHeight !== 0) {
            obj.BlockHeight = Math.round(message.BlockHeight);
        }
        if (message.BlockTime !== undefined) {
            obj.BlockTime = message.BlockTime.toISOString();
        }
        return obj;
    },
    create(base) {
        return GoodTil.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGoodTil();
        message.BlockHeight = (_a = object.BlockHeight) !== null && _a !== void 0 ? _a : 0;
        message.BlockTime = (_b = object.BlockTime) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseOrders() {
    return { Orders: [], Offset: undefined };
}
export const Orders = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.Orders) {
            Order.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.Offset !== undefined) {
            writer.uint32(16).int32(message.Offset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOrders();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.Orders.push(Order.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.Offset = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Orders: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.Orders) ? object.Orders.map((e) => Order.fromJSON(e)) : [],
            Offset: isSet(object.Offset) ? globalThis.Number(object.Offset) : undefined,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.Orders) === null || _a === void 0 ? void 0 : _a.length) {
            obj.Orders = message.Orders.map((e) => Order.toJSON(e));
        }
        if (message.Offset !== undefined) {
            obj.Offset = Math.round(message.Offset);
        }
        return obj;
    },
    create(base) {
        return Orders.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseOrders();
        message.Orders = ((_a = object.Orders) === null || _a === void 0 ? void 0 : _a.map((e) => Order.fromPartial(e))) || [];
        message.Offset = (_b = object.Offset) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
