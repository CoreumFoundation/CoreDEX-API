// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: domain/ohlc/ohlc.proto
/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { MetaData } from "../metadata/metadata";
export const protobufPackage = "ohlc";
export var PeriodType;
(function (PeriodType) {
    PeriodType[PeriodType["PERIOD_TYPE_DO_NOT_USE"] = 0] = "PERIOD_TYPE_DO_NOT_USE";
    PeriodType[PeriodType["PERIOD_TYPE_MINUTE"] = 1] = "PERIOD_TYPE_MINUTE";
    PeriodType[PeriodType["PERIOD_TYPE_HOUR"] = 2] = "PERIOD_TYPE_HOUR";
    PeriodType[PeriodType["PERIOD_TYPE_DAY"] = 3] = "PERIOD_TYPE_DAY";
    PeriodType[PeriodType["PERIOD_TYPE_WEEK"] = 4] = "PERIOD_TYPE_WEEK";
    PeriodType[PeriodType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PeriodType || (PeriodType = {}));
export function periodTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "PERIOD_TYPE_DO_NOT_USE":
            return PeriodType.PERIOD_TYPE_DO_NOT_USE;
        case 1:
        case "PERIOD_TYPE_MINUTE":
            return PeriodType.PERIOD_TYPE_MINUTE;
        case 2:
        case "PERIOD_TYPE_HOUR":
            return PeriodType.PERIOD_TYPE_HOUR;
        case 3:
        case "PERIOD_TYPE_DAY":
            return PeriodType.PERIOD_TYPE_DAY;
        case 4:
        case "PERIOD_TYPE_WEEK":
            return PeriodType.PERIOD_TYPE_WEEK;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PeriodType.UNRECOGNIZED;
    }
}
export function periodTypeToJSON(object) {
    switch (object) {
        case PeriodType.PERIOD_TYPE_DO_NOT_USE:
            return "PERIOD_TYPE_DO_NOT_USE";
        case PeriodType.PERIOD_TYPE_MINUTE:
            return "PERIOD_TYPE_MINUTE";
        case PeriodType.PERIOD_TYPE_HOUR:
            return "PERIOD_TYPE_HOUR";
        case PeriodType.PERIOD_TYPE_DAY:
            return "PERIOD_TYPE_DAY";
        case PeriodType.PERIOD_TYPE_WEEK:
            return "PERIOD_TYPE_WEEK";
        case PeriodType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseOHLCs() {
    return { OHLCs: [] };
}
export const OHLCs = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.OHLCs) {
            OHLC.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOHLCs();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.OHLCs.push(OHLC.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { OHLCs: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.OHLCs) ? object.OHLCs.map((e) => OHLC.fromJSON(e)) : [] };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.OHLCs) === null || _a === void 0 ? void 0 : _a.length) {
            obj.OHLCs = message.OHLCs.map((e) => OHLC.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return OHLCs.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseOHLCs();
        message.OHLCs = ((_a = object.OHLCs) === null || _a === void 0 ? void 0 : _a.map((e) => OHLC.fromPartial(e))) || [];
        return message;
    },
};
function createBaseOHLC() {
    return {
        Symbol: "",
        Timestamp: undefined,
        Open: 0,
        High: 0,
        Low: 0,
        Close: 0,
        Volume: 0,
        NumberOfTrades: 0,
        Period: undefined,
        USDValue: undefined,
        QuoteVolume: 0,
        MetaData: undefined,
        OpenTime: undefined,
        CloseTime: undefined,
    };
}
export const OHLC = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.Symbol !== "") {
            writer.uint32(10).string(message.Symbol);
        }
        if (message.Timestamp !== undefined) {
            Timestamp.encode(toTimestamp(message.Timestamp), writer.uint32(18).fork()).ldelim();
        }
        if (message.Open !== 0) {
            writer.uint32(25).double(message.Open);
        }
        if (message.High !== 0) {
            writer.uint32(33).double(message.High);
        }
        if (message.Low !== 0) {
            writer.uint32(41).double(message.Low);
        }
        if (message.Close !== 0) {
            writer.uint32(49).double(message.Close);
        }
        if (message.Volume !== 0) {
            writer.uint32(57).double(message.Volume);
        }
        if (message.NumberOfTrades !== 0) {
            writer.uint32(64).int64(message.NumberOfTrades);
        }
        if (message.Period !== undefined) {
            Period.encode(message.Period, writer.uint32(74).fork()).ldelim();
        }
        if (message.USDValue !== undefined) {
            writer.uint32(81).double(message.USDValue);
        }
        if (message.QuoteVolume !== 0) {
            writer.uint32(89).double(message.QuoteVolume);
        }
        if (message.MetaData !== undefined) {
            MetaData.encode(message.MetaData, writer.uint32(162).fork()).ldelim();
        }
        if (message.OpenTime !== undefined) {
            Timestamp.encode(toTimestamp(message.OpenTime), writer.uint32(170).fork()).ldelim();
        }
        if (message.CloseTime !== undefined) {
            Timestamp.encode(toTimestamp(message.CloseTime), writer.uint32(178).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOHLC();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.Symbol = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.Timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 25) {
                        break;
                    }
                    message.Open = reader.double();
                    continue;
                case 4:
                    if (tag !== 33) {
                        break;
                    }
                    message.High = reader.double();
                    continue;
                case 5:
                    if (tag !== 41) {
                        break;
                    }
                    message.Low = reader.double();
                    continue;
                case 6:
                    if (tag !== 49) {
                        break;
                    }
                    message.Close = reader.double();
                    continue;
                case 7:
                    if (tag !== 57) {
                        break;
                    }
                    message.Volume = reader.double();
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.NumberOfTrades = longToNumber(reader.int64());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.Period = Period.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 81) {
                        break;
                    }
                    message.USDValue = reader.double();
                    continue;
                case 11:
                    if (tag !== 89) {
                        break;
                    }
                    message.QuoteVolume = reader.double();
                    continue;
                case 20:
                    if (tag !== 162) {
                        break;
                    }
                    message.MetaData = MetaData.decode(reader, reader.uint32());
                    continue;
                case 21:
                    if (tag !== 170) {
                        break;
                    }
                    message.OpenTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 22:
                    if (tag !== 178) {
                        break;
                    }
                    message.CloseTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Symbol: isSet(object.Symbol) ? globalThis.String(object.Symbol) : "",
            Timestamp: isSet(object.Timestamp) ? fromJsonTimestamp(object.Timestamp) : undefined,
            Open: isSet(object.Open) ? globalThis.Number(object.Open) : 0,
            High: isSet(object.High) ? globalThis.Number(object.High) : 0,
            Low: isSet(object.Low) ? globalThis.Number(object.Low) : 0,
            Close: isSet(object.Close) ? globalThis.Number(object.Close) : 0,
            Volume: isSet(object.Volume) ? globalThis.Number(object.Volume) : 0,
            NumberOfTrades: isSet(object.NumberOfTrades) ? globalThis.Number(object.NumberOfTrades) : 0,
            Period: isSet(object.Period) ? Period.fromJSON(object.Period) : undefined,
            USDValue: isSet(object.USDValue) ? globalThis.Number(object.USDValue) : undefined,
            QuoteVolume: isSet(object.QuoteVolume) ? globalThis.Number(object.QuoteVolume) : 0,
            MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
            OpenTime: isSet(object.OpenTime) ? fromJsonTimestamp(object.OpenTime) : undefined,
            CloseTime: isSet(object.CloseTime) ? fromJsonTimestamp(object.CloseTime) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.Symbol !== "") {
            obj.Symbol = message.Symbol;
        }
        if (message.Timestamp !== undefined) {
            obj.Timestamp = message.Timestamp.toISOString();
        }
        if (message.Open !== 0) {
            obj.Open = message.Open;
        }
        if (message.High !== 0) {
            obj.High = message.High;
        }
        if (message.Low !== 0) {
            obj.Low = message.Low;
        }
        if (message.Close !== 0) {
            obj.Close = message.Close;
        }
        if (message.Volume !== 0) {
            obj.Volume = message.Volume;
        }
        if (message.NumberOfTrades !== 0) {
            obj.NumberOfTrades = Math.round(message.NumberOfTrades);
        }
        if (message.Period !== undefined) {
            obj.Period = Period.toJSON(message.Period);
        }
        if (message.USDValue !== undefined) {
            obj.USDValue = message.USDValue;
        }
        if (message.QuoteVolume !== 0) {
            obj.QuoteVolume = message.QuoteVolume;
        }
        if (message.MetaData !== undefined) {
            obj.MetaData = MetaData.toJSON(message.MetaData);
        }
        if (message.OpenTime !== undefined) {
            obj.OpenTime = message.OpenTime.toISOString();
        }
        if (message.CloseTime !== undefined) {
            obj.CloseTime = message.CloseTime.toISOString();
        }
        return obj;
    },
    create(base) {
        return OHLC.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const message = createBaseOHLC();
        message.Symbol = (_a = object.Symbol) !== null && _a !== void 0 ? _a : "";
        message.Timestamp = (_b = object.Timestamp) !== null && _b !== void 0 ? _b : undefined;
        message.Open = (_c = object.Open) !== null && _c !== void 0 ? _c : 0;
        message.High = (_d = object.High) !== null && _d !== void 0 ? _d : 0;
        message.Low = (_e = object.Low) !== null && _e !== void 0 ? _e : 0;
        message.Close = (_f = object.Close) !== null && _f !== void 0 ? _f : 0;
        message.Volume = (_g = object.Volume) !== null && _g !== void 0 ? _g : 0;
        message.NumberOfTrades = (_h = object.NumberOfTrades) !== null && _h !== void 0 ? _h : 0;
        message.Period = (object.Period !== undefined && object.Period !== null)
            ? Period.fromPartial(object.Period)
            : undefined;
        message.USDValue = (_j = object.USDValue) !== null && _j !== void 0 ? _j : undefined;
        message.QuoteVolume = (_k = object.QuoteVolume) !== null && _k !== void 0 ? _k : 0;
        message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
            ? MetaData.fromPartial(object.MetaData)
            : undefined;
        message.OpenTime = (_l = object.OpenTime) !== null && _l !== void 0 ? _l : undefined;
        message.CloseTime = (_m = object.CloseTime) !== null && _m !== void 0 ? _m : undefined;
        return message;
    },
};
function createBasePeriod() {
    return { PeriodType: 0, Duration: 0 };
}
export const Period = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.PeriodType !== 0) {
            writer.uint32(8).int32(message.PeriodType);
        }
        if (message.Duration !== 0) {
            writer.uint32(16).int32(message.Duration);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePeriod();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.PeriodType = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.Duration = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            PeriodType: isSet(object.PeriodType) ? periodTypeFromJSON(object.PeriodType) : 0,
            Duration: isSet(object.Duration) ? globalThis.Number(object.Duration) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.PeriodType !== 0) {
            obj.PeriodType = periodTypeToJSON(message.PeriodType);
        }
        if (message.Duration !== 0) {
            obj.Duration = Math.round(message.Duration);
        }
        return obj;
    },
    create(base) {
        return Period.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePeriod();
        message.PeriodType = (_a = object.PeriodType) !== null && _a !== void 0 ? _a : 0;
        message.Duration = (_b = object.Duration) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
