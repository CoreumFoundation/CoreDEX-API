// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: domain/trade/trade.proto
/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Decimal } from "../decimal/decimal";
import { Denom } from "../denom/denom";
import { MetaData } from "../metadata/metadata";
import { sideFromJSON, sideToJSON } from "../order-properties/order-properties";
export const protobufPackage = "trade";
function createBaseTrade() {
    return {
        Account: "",
        OrderID: "",
        Sequence: 0,
        Amount: undefined,
        Price: 0,
        Denom1: undefined,
        Denom2: undefined,
        Side: 0,
        BlockTime: undefined,
        MetaData: undefined,
        TXID: undefined,
        BlockHeight: 0,
        Enriched: false,
        USD: undefined,
    };
}
export const Trade = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.Account !== "") {
            writer.uint32(10).string(message.Account);
        }
        if (message.OrderID !== "") {
            writer.uint32(18).string(message.OrderID);
        }
        if (message.Sequence !== 0) {
            writer.uint32(24).int64(message.Sequence);
        }
        if (message.Amount !== undefined) {
            Decimal.encode(message.Amount, writer.uint32(34).fork()).ldelim();
        }
        if (message.Price !== 0) {
            writer.uint32(41).double(message.Price);
        }
        if (message.Denom1 !== undefined) {
            Denom.encode(message.Denom1, writer.uint32(50).fork()).ldelim();
        }
        if (message.Denom2 !== undefined) {
            Denom.encode(message.Denom2, writer.uint32(58).fork()).ldelim();
        }
        if (message.Side !== 0) {
            writer.uint32(64).int32(message.Side);
        }
        if (message.BlockTime !== undefined) {
            Timestamp.encode(toTimestamp(message.BlockTime), writer.uint32(74).fork()).ldelim();
        }
        if (message.MetaData !== undefined) {
            MetaData.encode(message.MetaData, writer.uint32(242).fork()).ldelim();
        }
        if (message.TXID !== undefined) {
            writer.uint32(250).string(message.TXID);
        }
        if (message.BlockHeight !== 0) {
            writer.uint32(256).int64(message.BlockHeight);
        }
        if (message.Enriched !== false) {
            writer.uint32(264).bool(message.Enriched);
        }
        if (message.USD !== undefined) {
            writer.uint32(325).float(message.USD);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTrade();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.Account = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.OrderID = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.Sequence = longToNumber(reader.int64());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.Amount = Decimal.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 41) {
                        break;
                    }
                    message.Price = reader.double();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.Denom1 = Denom.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.Denom2 = Denom.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.Side = reader.int32();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.BlockTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 30:
                    if (tag !== 242) {
                        break;
                    }
                    message.MetaData = MetaData.decode(reader, reader.uint32());
                    continue;
                case 31:
                    if (tag !== 250) {
                        break;
                    }
                    message.TXID = reader.string();
                    continue;
                case 32:
                    if (tag !== 256) {
                        break;
                    }
                    message.BlockHeight = longToNumber(reader.int64());
                    continue;
                case 33:
                    if (tag !== 264) {
                        break;
                    }
                    message.Enriched = reader.bool();
                    continue;
                case 40:
                    if (tag !== 325) {
                        break;
                    }
                    message.USD = reader.float();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Account: isSet(object.Account) ? globalThis.String(object.Account) : "",
            OrderID: isSet(object.OrderID) ? globalThis.String(object.OrderID) : "",
            Sequence: isSet(object.Sequence) ? globalThis.Number(object.Sequence) : 0,
            Amount: isSet(object.Amount) ? Decimal.fromJSON(object.Amount) : undefined,
            Price: isSet(object.Price) ? globalThis.Number(object.Price) : 0,
            Denom1: isSet(object.Denom1) ? Denom.fromJSON(object.Denom1) : undefined,
            Denom2: isSet(object.Denom2) ? Denom.fromJSON(object.Denom2) : undefined,
            Side: isSet(object.Side) ? sideFromJSON(object.Side) : 0,
            BlockTime: isSet(object.BlockTime) ? fromJsonTimestamp(object.BlockTime) : undefined,
            MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
            TXID: isSet(object.TXID) ? globalThis.String(object.TXID) : undefined,
            BlockHeight: isSet(object.BlockHeight) ? globalThis.Number(object.BlockHeight) : 0,
            Enriched: isSet(object.Enriched) ? globalThis.Boolean(object.Enriched) : false,
            USD: isSet(object.USD) ? globalThis.Number(object.USD) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.Account !== "") {
            obj.Account = message.Account;
        }
        if (message.OrderID !== "") {
            obj.OrderID = message.OrderID;
        }
        if (message.Sequence !== 0) {
            obj.Sequence = Math.round(message.Sequence);
        }
        if (message.Amount !== undefined) {
            obj.Amount = Decimal.toJSON(message.Amount);
        }
        if (message.Price !== 0) {
            obj.Price = message.Price;
        }
        if (message.Denom1 !== undefined) {
            obj.Denom1 = Denom.toJSON(message.Denom1);
        }
        if (message.Denom2 !== undefined) {
            obj.Denom2 = Denom.toJSON(message.Denom2);
        }
        if (message.Side !== 0) {
            obj.Side = sideToJSON(message.Side);
        }
        if (message.BlockTime !== undefined) {
            obj.BlockTime = message.BlockTime.toISOString();
        }
        if (message.MetaData !== undefined) {
            obj.MetaData = MetaData.toJSON(message.MetaData);
        }
        if (message.TXID !== undefined) {
            obj.TXID = message.TXID;
        }
        if (message.BlockHeight !== 0) {
            obj.BlockHeight = Math.round(message.BlockHeight);
        }
        if (message.Enriched !== false) {
            obj.Enriched = message.Enriched;
        }
        if (message.USD !== undefined) {
            obj.USD = message.USD;
        }
        return obj;
    },
    create(base) {
        return Trade.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseTrade();
        message.Account = (_a = object.Account) !== null && _a !== void 0 ? _a : "";
        message.OrderID = (_b = object.OrderID) !== null && _b !== void 0 ? _b : "";
        message.Sequence = (_c = object.Sequence) !== null && _c !== void 0 ? _c : 0;
        message.Amount = (object.Amount !== undefined && object.Amount !== null)
            ? Decimal.fromPartial(object.Amount)
            : undefined;
        message.Price = (_d = object.Price) !== null && _d !== void 0 ? _d : 0;
        message.Denom1 = (object.Denom1 !== undefined && object.Denom1 !== null)
            ? Denom.fromPartial(object.Denom1)
            : undefined;
        message.Denom2 = (object.Denom2 !== undefined && object.Denom2 !== null)
            ? Denom.fromPartial(object.Denom2)
            : undefined;
        message.Side = (_e = object.Side) !== null && _e !== void 0 ? _e : 0;
        message.BlockTime = (_f = object.BlockTime) !== null && _f !== void 0 ? _f : undefined;
        message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
            ? MetaData.fromPartial(object.MetaData)
            : undefined;
        message.TXID = (_g = object.TXID) !== null && _g !== void 0 ? _g : undefined;
        message.BlockHeight = (_h = object.BlockHeight) !== null && _h !== void 0 ? _h : 0;
        message.Enriched = (_j = object.Enriched) !== null && _j !== void 0 ? _j : false;
        message.USD = (_k = object.USD) !== null && _k !== void 0 ? _k : undefined;
        return message;
    },
};
function createBaseTrades() {
    return { Trades: [] };
}
export const Trades = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.Trades) {
            Trade.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTrades();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.Trades.push(Trade.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { Trades: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.Trades) ? object.Trades.map((e) => Trade.fromJSON(e)) : [] };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.Trades) === null || _a === void 0 ? void 0 : _a.length) {
            obj.Trades = message.Trades.map((e) => Trade.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Trades.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseTrades();
        message.Trades = ((_a = object.Trades) === null || _a === void 0 ? void 0 : _a.map((e) => Trade.fromPartial(e))) || [];
        return message;
    },
};
function createBaseTradePair() {
    return { Denom1: undefined, Denom2: undefined, MetaData: undefined };
}
export const TradePair = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.Denom1 !== undefined) {
            Denom.encode(message.Denom1, writer.uint32(10).fork()).ldelim();
        }
        if (message.Denom2 !== undefined) {
            Denom.encode(message.Denom2, writer.uint32(18).fork()).ldelim();
        }
        if (message.MetaData !== undefined) {
            MetaData.encode(message.MetaData, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTradePair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.Denom1 = Denom.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.Denom2 = Denom.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.MetaData = MetaData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            Denom1: isSet(object.Denom1) ? Denom.fromJSON(object.Denom1) : undefined,
            Denom2: isSet(object.Denom2) ? Denom.fromJSON(object.Denom2) : undefined,
            MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.Denom1 !== undefined) {
            obj.Denom1 = Denom.toJSON(message.Denom1);
        }
        if (message.Denom2 !== undefined) {
            obj.Denom2 = Denom.toJSON(message.Denom2);
        }
        if (message.MetaData !== undefined) {
            obj.MetaData = MetaData.toJSON(message.MetaData);
        }
        return obj;
    },
    create(base) {
        return TradePair.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseTradePair();
        message.Denom1 = (object.Denom1 !== undefined && object.Denom1 !== null)
            ? Denom.fromPartial(object.Denom1)
            : undefined;
        message.Denom2 = (object.Denom2 !== undefined && object.Denom2 !== null)
            ? Denom.fromPartial(object.Denom2)
            : undefined;
        message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
            ? MetaData.fromPartial(object.MetaData)
            : undefined;
        return message;
    },
};
function createBaseTradePairs() {
    return { TradePairs: [], Offset: undefined };
}
export const TradePairs = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.TradePairs) {
            TradePair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.Offset !== undefined) {
            writer.uint32(16).int32(message.Offset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTradePairs();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.TradePairs.push(TradePair.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.Offset = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            TradePairs: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.TradePairs)
                ? object.TradePairs.map((e) => TradePair.fromJSON(e))
                : [],
            Offset: isSet(object.Offset) ? globalThis.Number(object.Offset) : undefined,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.TradePairs) === null || _a === void 0 ? void 0 : _a.length) {
            obj.TradePairs = message.TradePairs.map((e) => TradePair.toJSON(e));
        }
        if (message.Offset !== undefined) {
            obj.Offset = Math.round(message.Offset);
        }
        return obj;
    },
    create(base) {
        return TradePairs.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTradePairs();
        message.TradePairs = ((_a = object.TradePairs) === null || _a === void 0 ? void 0 : _a.map((e) => TradePair.fromPartial(e))) || [];
        message.Offset = (_b = object.Offset) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
